## Пример репозитория микросервисного приложения 

[![CircleCI](https://circleci.com/gh/REAL-NET/microservices-sample/tree/master.svg?style=svg)](https://circleci.com/gh/REAL-NET/microservices-sample/tree/master)

### Как это устроено
В репозитории имеются два микросервиса, каждый из которых
билдится в свой образ контейнера Docker. 
Кроме этого, средствами CircleCI реализована сборка образов удаленно,
которые затем размещаются в хранилице GitHub Registry. 

### Как запустить
В корне репозитория имеется скрипт `run.sh`, который 
* Получает текущую рабочую ветку git
* Запускает docker контейнеры, соответствующие этой ветке
* Если образы этих контенеров представлены локально, он запускает их
* Иначе он сам докачивает соответсвующие образы из GitHub Registry 
(соответственно он может спросить логин и пароль (или токен))

О том, какие порты используются для каждого контейнера, указано в
параметре `-p`. Например, при запуска с `-p 8000:80` можно получить
ответ с `localhost:8000` (пока только по http)

Если git не настроен в текущей папке, по умолчанию используются образы
с ветки `master`.

Если же работа происходит в локальной ветке, и пока никакие образы
не выложены в GitHub Registry, то перед запуском эти образы нужно
собрать локально, т.е. выполнить `build.sh`.

### CI
Сейчас сборка и выкладка образов осужествляется для каждой ветки
в репозитории. Для каждой ветки создается свой образ, отличающийся тегом,
например 

    docker.pkg.github.com/real-net/microservices-sample/goodbye:master
    docker.pkg.github.com/real-net/microservices-sample/goodbye:dev-sample 
    
Соответсвенно, при запуске через `run.sh` используется образ с 
тегом текущей рабочей ветки.

Конфигурация CircleCI достаточно легко переносима. Путем внимательного
вгляда и замены значений переменных и переменных окружения, можно 
настроить деплой для любого подобного проекта. 
Для доступа в Registry может потребоваться выписать токен.

Шаги задаются для каждого сервиса независимо. Таким образом,
сборка и выкладка одного не влияет на другие. 
Шаги описаны как параментирозованные команды, так что для переноса в
свой проект нужно только поменять переменные окружения и 
указать правильный порядок шагов с правильными параметрами.
 
